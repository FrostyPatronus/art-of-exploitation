$ gdb -q a.out
Reading symbols from a.out...done.
(gdb) break 7
Breakpoint 1 at 0x4005fb: file scope.c, line 7.
(gdb) run
Starting program: /home/frosty/hack/chapter_2/code/a.out 
[main] i @ 0x7fffffffded4 = 3
[main] j @ 0x601048 = 42
    [func1] i @ 0x7fffffffdeb4 = 5
    [func1] j @ 0x601048 = 42
        [func2] i @ 0x7fffffffde94 = 7
        [func2] j @ 0x601048 = 42
        [func2] j = 1336

Breakpoint 1, func3 () at scope.c:7
7       printf("\t\t\t[func3] i @ %p = %d\n", &i, i);
(gdb) bt
#0  func3 () at scope.c:7
#1  0x00000000004006b5 in func2 () at scope.c:19
#2  0x000000000040075e in func1 () at scope.c:31
#3  0x0000000000400807 in main () at scope.c:43
(gdb) 

"bt full" will provide where the stack trace went and will print the local variables inside

(gdb) bt full
#0  func3 () at scope.c:7
        i = 11
        j = 999
#1  0x00000000004006b5 in func2 () at scope.c:19
        i = 7
#2  0x000000000040075e in func1 () at scope.c:31
        i = 5
#3  0x0000000000400807 in main () at scope.c:43
        i = 3

Values in the function arguments are pushed in the reverse order:
-- Parent Function --

   0x000000000040058f <+4>:     mov    ecx,0x4
   0x0000000000400594 <+9>:     mov    edx,0x3
   0x0000000000400599 <+14>:    mov    esi,0x2
   0x000000000040059e <+19>:    mov    edi,0x1

-- Called Function --
   0x000000000040054e <+8>:     mov    DWORD PTR [rbp-0x34],edi
   0x0000000000400551 <+11>:    mov    DWORD PTR [rbp-0x38],esi
   0x0000000000400554 <+14>:    mov    DWORD PTR [rbp-0x3c],edx
   0x0000000000400557 <+17>:    mov    DWORD PTR [rbp-0x40],ecx

First In (ecx with the value of 0x4) will be put into the called function last (DWORD PTR [rpb-0x40])

Reading symbols from a.out...done.
(gdb) list
1   void test_function(int a, int b, int c, int d) {
2       int flag;
3       char buffer[10];
4       flag = 31337;
5       buffer[0] = 'A';
6   }
7   
8   int main() {
9       test_function(1, 2, 3, 4);
10  }
(gdb) break
No default breakpoint address now.
(gdb) break 9
Breakpoint 1 at 0x40058f: file stack_example.c, line 9.
(gdb) break test_function 
Breakpoint 2 at 0x40055a: file stack_example.c, line 1.
(gdb) run
Starting program: /home/frosty/hack/chapter_2/code/a.out 

Breakpoint 1, main () at stack_example.c:9
9       test_function(1, 2, 3, 4);
(gdb) disass main
Dump of assembler code for function main:
   0x000000000040058b <+0>: push   rbp
   0x000000000040058c <+1>: mov    rbp,rsp
=> 0x000000000040058f <+4>: mov    ecx,0x4
   0x0000000000400594 <+9>: mov    edx,0x3
   0x0000000000400599 <+14>:    mov    esi,0x2
   0x000000000040059e <+19>:    mov    edi,0x1
   0x00000000004005a3 <+24>:    call   0x400546 <test_function>
   0x00000000004005a8 <+29>:    mov    eax,0x0
   0x00000000004005ad <+34>:    pop    rbp
   0x00000000004005ae <+35>:    ret    
End of assembler dump.
(gdb) i r rbp rsp rip
rbp            0x7fffffffdee0   0x7fffffffdee0
rsp            0x7fffffffdee0   0x7fffffffdee0
rip            0x40058f 0x40058f <main+4>
(gdb) continue 
Continuing.

Breakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:1
1   void test_function(int a, int b, int c, int d) {
(gdb) disass test_function 
Dump of assembler code for function test_function:
   0x0000000000400546 <+0>: push   rbp
   0x0000000000400547 <+1>: mov    rbp,rsp
   0x000000000040054a <+4>: sub    rsp,0x40
   0x000000000040054e <+8>: mov    DWORD PTR [rbp-0x34],edi
   0x0000000000400551 <+11>:    mov    DWORD PTR [rbp-0x38],esi
   0x0000000000400554 <+14>:    mov    DWORD PTR [rbp-0x3c],edx
   0x0000000000400557 <+17>:    mov    DWORD PTR [rbp-0x40],ecx
=> 0x000000000040055a <+20>:    mov    rax,QWORD PTR fs:0x28
   0x0000000000400563 <+29>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000000000400567 <+33>:    xor    eax,eax
   0x0000000000400569 <+35>:    mov    DWORD PTR [rbp-0x24],0x7a69
   0x0000000000400570 <+42>:    mov    BYTE PTR [rbp-0x20],0x41
   0x0000000000400574 <+46>:    nop
   0x0000000000400575 <+47>:    mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000400579 <+51>:    xor    rax,QWORD PTR fs:0x28
   0x0000000000400582 <+60>:    je     0x400589 <test_function+67>
   0x0000000000400584 <+62>:    call   0x400420 <__stack_chk_fail@plt>
   0x0000000000400589 <+67>:    leave  
   0x000000000040058a <+68>:    ret    
End of assembler dump.
(gdb) i r rbp rsp rip
rbp            0x7fffffffded0   0x7fffffffded0
rsp            0x7fffffffde90   0x7fffffffde90
rip            0x40055a 0x40055a <test_function+20>
(gdb) p 
The history is empty.
(gdb) p 0x7fffffffded0-0x7fffffffdee0
$1 = -16
(gdb) x/32xw $rsp
0x7fffffffde90: 0x00000004  0x00000003  0x00000002  0x00000001 ; Variable a, b, c, d
0x7fffffffdea0: 0x00000001  0x00000000  0x004005fd  0x00000000 ; Flag Variable
0x7fffffffdeb0: 0x00000000  0x00000000  0x00000000  0x00000000 ; Buffer variable
0x7fffffffdec0: 0x004005b0  0x00000000  0x00400450  0x00000000
0x7fffffffded0: 0xffffdee0  0x00007fff  0x004005a8  0x00000000 ; Saved Frame Pointer (0x7fffffffdee0) and the return pointer (0x4005a8) 
0x7fffffffdee0: 0x004005b0  0x00000000  0xf7a2e830  0x00007fff
0x7fffffffdef0: 0x00000000  0x00000000  0xffffdfc8  0x00007fff
0x7fffffffdf00: 0xf7ffcca0  0x00000001  0x0040058b  0x00000000
(gdb) p $rbp-0x24
$2 = (void *) 0x7fffffffdeac
(gdb) p $rbp-0x20
$3 = (void *) 0x7fffffffdeb0

https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point

Why there is a gap between the rsp of the parent function and the rbp of the called function

 Î» gdb -q a.out
Reading symbols from a.out...done.
(gdb) list
1   void test_function(int a, int b, int c, int d) {
2       int flag;
3       char buffer[10];
4       flag = 31337;
5       buffer[0] = 'A';
6   }
7   
8   int main() {
9       test_function(1, 2, 3, 4);
10  }
(gdb) break 9
Breakpoint 1 at 0x40058f: file stack_example.c, line 9.
(gdb) break test_function 
Breakpoint 2 at 0x40055a: file stack_example.c, line 1.
(gdb) 
Note: breakpoint 2 also set at pc 0x40055a.
Breakpoint 3 at 0x40055a: file stack_example.c, line 1.
(gdb) run
Starting program: /home/frosty/hack/chapter_2/code/a.out 

Breakpoint 1, main () at stack_example.c:9
9       test_function(1, 2, 3, 4);
(gdb) i r rsp rbp rip
rsp            0x7fffffffdee0   0x7fffffffdee0
rbp            0x7fffffffdee0   0x7fffffffdee0
rip            0x40058f 0x40058f <main+4>
(gdb) continue 
Continuing.

Breakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:1
1   void test_function(int a, int b, int c, int d) {
(gdb) i r rsp rbp rip
rsp            0x7fffffffde90   0x7fffffffde90
rbp            0x7fffffffded0   0x7fffffffded0
rip            0x40055a 0x40055a <test_function+20>
(gdb) p 0x7fffffffded0-0x7fffffffdee0
$1 = -16
(gdb) x/4wx 0x7fffffffdee0
0x7fffffffdee0: 0x004005b0  0x00000000  0xf7a2e830  0x00007fff
(gdb) x/8wx 0x7fffffffdee0
0x7fffffffdee0: 0x004005b0  0x00000000  0xf7a2e830  0x00007fff
0x7fffffffdef0: 0x00000000  0x00000000  0xffffdfc8  0x00007fff
(gdb) x/8wx 0x7fffffffded0
0x7fffffffded0: 0xffffdee0  0x00007fff  0x004005a8  0x00000000
0x7fffffffdee0: 0x004005b0  0x00000000  0xf7a2e830  0x00007fff
(gdb) x/4wx 0x7fffffffded0
0x7fffffffded0: 0xffffdee0  0x00007fff  0x004005a8  0x00000000
(gdb) 

It's because that gap is filled by the Saved Frame Pointer (RBP of the previous stack frame) and the return address
