#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>     // Defines flags used in the open function
#include <sys/stat.h>  // Defines flags used in the open function
#include <unistd.h>    // Defines the open function
#include "functions.h"

#define FILENAME "/var/notes"

int print_notes(int, int, char*);
int find_user_note(int, int);
int search_note(char*, char*);
 
int main(int argc, char* argv[]) {
    char searchstring[100];
    if(argc > 1)
        strcpy(searchstring, argv[1]);
    else
        searchstring[0] = 0;
    
    int userid = getuid();
    printf("[DEBUG] UserID: %d\n", userid);

    int fd = open(FILENAME, O_RDONLY); 
    printf("[DEBUG] File Descriptor: %d\n", fd);
    if(fd == -1)
        fatal("in main() while opening file for reading");
    
    int printing = 1;
    while (printing)
        printing = print_notes(fd, userid, searchstring);

    printf("---------[ end of note data ]---------\n");
    close(fd);
}

int print_notes(int fd, int uid, char *searchstring){
    int note_length = find_user_note(fd, uid);
    
    if (note_length == -1) 
        return 0; // End of file
    
    char note_buffer[100];
    read(fd, note_buffer, note_length);
    
    note_buffer[note_length] = '\0'; // null terminator byte

    if(search_note(note_buffer, searchstring)) {
        printf("%s", note_buffer);
    }
    return 1;
}

// Returns the length of the first message which matches the user_uid
// Puts the read cursor at the start of the first found message 
int find_user_note(int fd, int user_uid) {
    int note_uid = -1;
    unsigned char byte;
    int length;
    // While loop continues until it reads anything in the file 
    // with the user id followed by a new line
    while (note_uid != user_uid) {
        if(read(fd, &note_uid, 4) != 4) // if read fails (end of file)
            return -1;
        if(read(fd, &byte, 1) != 1) // if read fails
            return -1;

        // Resets length in case that this is failed. Inefficient!!!
        byte = 0;
        length = 0;

        while(byte != '\n') {
            if(read(fd, &byte, 1) != 1)
                return -1;
            length++;
        }
    }

    // rewind read cursor to start of message 
    int debug = lseek(fd, length * -1, SEEK_CUR); 
    
    printf("[DEBUG] %d byte note for UID %d\n", length, user_uid);
    return length;
}

// return 0 if keyword is not in note, return 1 if it is
int search_note(char *note, char *keyword) {
    int keyword_length = strlen(keyword);

    if (keyword_length == 0)
        return 1;
    
    int i;
    int match = 0; // Counts how many matched chars there are
    for (i = 0; i < strlen(note); i++) {
        if (note[i] == keyword[match]) {
            match++;
        } else {
            // match = 0; // If we do this, we're ignoring the possibility that the first unmatched character in the old streak can be the first matched character in the new streak
            
            if (note[i] == keyword[0]) 
                match = 1;
            else 
                match = 0;
        }
        
        if (keyword_length == match)
            return 1;
    }

    return 0;
}
