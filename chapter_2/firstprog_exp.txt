objdump -D a.out | grep -A20 main.:
This outputs assembly code for this program. The far left is the 
memory addresses that the CPU will access to retrieve the machine
language instructions of the program.

This is in intel syntax 
/*
0000000000400526 <main>:
  400526: 55                      push   rbp
  400527: 48 89 e5                mov    rbp,rsp
  40052a: 48 83 ec 10             sub    rsp,0x10
  40052e: c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
  400535: eb 0e                   jmp    400545 <main+0x1f>
  400537: bf e4 05 40 00          mov    edi,0x4005e4
  40053c: e8 bf fe ff ff          call   400400 <puts@plt>
  400541: 83 45 fc 01             add    DWORD PTR [rbp-0x4],0x1
  400545: 83 7d fc 09             cmp    DWORD PTR [rbp-0x4],0x9
  400549: 7e ec                   jle    400537 <main+0x11>
  40054b: b8 00 00 00 00          mov    eax,0x0
  400550: c9                      leave  
  400551: c3                      ret    
  400552: 66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]
  400559: 00 00 00 
  40055c: 0f 1f 40 00             nop    DWORD PTR [rax+0x0]
*/

The part on the far left is the memory address where the
instructions are stored in hexadecimal

The part on the middle is the actual instructions in hexadecimal

The part on the right is the instructions in the middle translated
into assembly language

Assembly is a way for programmers to represent machine language
instructions

objdump -M intel -D  a.out | grep -A20 main.:
This will output the assembly code in intel syntax

* TRUNCATED THE TRAILING 0s 
0x400526 <+0>:  push   rbp
0x400527 <+1>:  mov    rbp,rsp
0x40052a <+4>:  sub    rsp,0x10
0x40052e <+8>:  mov    DWORD PTR [rbp-0x4],0x0
0x400535 <+15>: jmp    0x400545 <main+31>
0x400537 <+17>: mov    edi,0x4005e4
0x40053c <+22>: call   0x400400 <puts@plt>
0x400541 <+27>: add    DWORD PTR [rbp-0x4],0x1
0x400545 <+31>: cmp    DWORD PTR [rbp-0x4],0x9
0x400549 <+35>: jle    0x400537 <main+17>
0x40054b <+37>: mov    eax,0x0
0x400550 <+42>: leave  
0x400551 <+43>: ret  

(gdb) info register rip
rip            0x40052e  0x40052e <main+8>
The instruction pointer register is at 40052e, at 
DWORD PTR [rbp-0x4],0x0

This is all when nothing has been executed yet because a breakpoint
is put in the start of main

0x400526 <+0>:  push   rbp
0x400527 <+1>:  mov    rbp,rsp
0x40052a <+4>:  sub    rsp,0x10

The assembly before the main function's disassembly is called the 
function prologue. Needs to set up memory for the main function's 
local variables. (Also why you need to define variable types in C. It
helps in making this) GDB skips over it.


